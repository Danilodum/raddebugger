// Copyright (c) 2024 Epic Games Tools
// Licensed under the MIT license (https://opensource.org/license/mit/)

//- GENERATED CODE

#ifndef RENDER_OPENGL_META_H
#define RENDER_OPENGL_META_H

typedef enum R_GL_VShadKind
{
R_GL_VShadKind_Rect,
R_GL_VShadKind_Blur,
R_GL_VShadKind_Mesh,
R_GL_VShadKind_FullscreenQuad,
R_GL_VShadKind_COUNT,
} R_GL_VShadKind;

typedef enum R_GL_PShadKind
{
R_GL_PShadKind_Rect,
R_GL_PShadKind_Blur,
R_GL_PShadKind_Mesh,
R_GL_PShadKind_Geo3DComposite,
R_GL_PShadKind_Finalize,
R_GL_PShadKind_COUNT,
} R_GL_PShadKind;

typedef enum R_GL_UniformTypeKind
{
R_GL_UniformTypeKind_Rect,
R_GL_UniformTypeKind_Blur,
R_GL_UniformTypeKind_Mesh,
R_GL_UniformTypeKind_COUNT,
} R_GL_UniformTypeKind;

C_LINKAGE_BEGIN
read_only global String8 r_gl_g_rect_shader_vs_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"// Instance inputs matching VAO setup (8 vec4s)\n"
"layout(location = 0) in vec4 dst_rect_px_in;     // {x0, y0, x1, y1}\n"
"layout(location = 1) in vec4 src_rect_px_in;     // {x0, y0, x1, y1}\n"
"layout(location = 2) in vec4 color00_in;         // {r, g, b, a} BL\n"
"layout(location = 3) in vec4 color01_in;         // {r, g, b, a} TL\n"
"layout(location = 4) in vec4 color10_in;         // {r, g, b, a} BR\n"
"layout(location = 5) in vec4 color11_in;         // {r, g, b, a} TR\n"
"layout(location = 6) in vec4 corner_radii_px_in; // {bl, tl, br, tr} - CHECK ORDER vs D3D11\n"
"layout(location = 7) in vec4 style_params_in;    // {border, soft, omit_tex, unused}\n"
"\n"
"// Uniforms (Unchanged)\n"
"layout (std140) uniform R_GL_Uniforms_Rect { // Binding Point 0\n"
"  vec2 viewport_size_px;\n"
"  float opacity;\n"
"  mat4 texture_sample_channel_map;\n"
"  vec2 texture_t2d_size_px;\n"
"  mat3 xform; // Column-major\n"
"  vec2 xform_scale;\n"
"};\n"
"\n"
"// Outputs to Fragment Shader (Matches D3D11 rect shader outputs)\n"
"out VS_OUT {\n"
"  vec2 rect_half_size_px;\n"
"  vec2 texcoord_pct;\n"
"  vec2 sdf_sample_pos;\n"
"  vec4 tint;\n"
"  float corner_radius_px;\n"
"  flat float border_thickness_px;\n"
"  flat float softness_px;\n"
"  flat float omit_texture;\n"
"} vs_out;\n"
"\n"
"void main() {\n"
"  // Unpack instance data\n"
"  vec2 dst_p0_px = dst_rect_px_in.xy;\n"
"  vec2 dst_p1_px = dst_rect_px_in.zw;\n"
"  vec2 src_p0_px = src_rect_px_in.xy;\n"
"  vec2 src_p1_px = src_rect_px_in.zw;\n"
"  vec2 dst_size_px = abs(dst_p1_px - dst_p0_px);\n"
"\n"
"  float border_thickness_px = style_params_in.x;\n"
"  float softness_px         = style_params_in.y;\n"
"  float omit_texture        = style_params_in.z;\n"
"\n"
"  // Generate standard CCW triangle strip quad vertex percentages (0,0), (1,0), (0,1), (1,1)\n"
"  // gl_VertexID 0 -> (0,0) -> BL\n"
"  // gl_VertexID 1 -> (1,0) -> BR\n"
"  // gl_VertexID 2 -> (0,1) -> TL\n"
"  // gl_VertexID 3 -> (1,1) -> TR\n"
"  vec2 vertex_pct = vec2(float(gl_VertexID & 1), float((gl_VertexID >> 1) & 1));\n"
"\n"
"  // Map vertex percentage to destination rect coordinates\n"
"  vec2 current_dst_pos_px = mix(dst_p0_px, dst_p1_px, vertex_pct);\n"
"\n"
"  // Calculate output position\n"
"  vec3 xformed_pos = xform * vec3(current_dst_pos_px, 1.0);\n"
"  vec2 ndc_pos = (xformed_pos.xy / viewport_size_px) * 2.0 - 1.0;\n"
"  ndc_pos.y = -ndc_pos.y; // Flip Y for GL NDC\n"
"  gl_Position = vec4(ndc_pos, 0.0, 1.0);\n"
"\n"
"  // Map vertex percentage to source rect coordinates for texture coords\n"
"  vec2 current_src_pos_px = mix(src_p0_px, src_p1_px, vertex_pct);\n"
"  vs_out.texcoord_pct = current_src_pos_px / texture_t2d_size_px;\n"
"\n"
"  // Select color based on vertex ID (matching D3D11 logic for vertex IDs 0..3 -> TL, BL, TR, BR)\n"
"  vec4 color_bl = color00_in; // Location 2\n"
"  vec4 color_br = color10_in; // Location 4\n"
"  vec4 color_tl = color01_in; // Location 3\n"
"  vec4 color_tr = color11_in; // Location 5\n"
"  vec4 colors[4] = vec4[4](color_bl, color_br, color_tl, color_tr); // GLSL array constructor syntax\n"
"  vs_out.tint = colors[gl_VertexID];\n"
"\n"
"  // Select corner radius based on vertex ID (matching D3D11 logic)\n"
"  // GL Vertex IDs 0, 1, 2, 3 correspond to BL, BR, TL, TR based on vertex_pct calc\n"
"  // Input corner_radii_px_in (loc 6) is {bl, tl, br, tr} -> {x, y, z, w}\n"
"  // D3D11 mapping (see thought process): ID 0 (BL)->x, ID 1 (BR)->z, ID 2 (TL)->y, ID 3 (TR)->w\n"
"  float radii[4] = float[4](corner_radii_px_in.x, corner_radii_px_in.z, corner_radii_px_in.y, corner_radii_px_in.w); // GLSL array constructor syntax\n"
"  vs_out.corner_radius_px = radii[gl_VertexID];\n"
"\n"
"  // Calculate SDF sample position based on vertex percentage relative to center\n"
"  vs_out.rect_half_size_px    = dst_size_px / 2.0 * xform_scale;\n"
"  vs_out.sdf_sample_pos       = (2.0 * vertex_pct - 1.0) * vs_out.rect_half_size_px;\n"
"\n"
"  // Pass through flat values\n"
"  vs_out.border_thickness_px  = border_thickness_px;\n"
"  vs_out.softness_px          = softness_px;\n"
"  vs_out.omit_texture         = omit_texture;\n"
"}\n"
""
);

read_only global String8 r_gl_g_rect_shader_fs_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"in VS_OUT {\n"
"  vec2 rect_half_size_px;\n"
"  vec2 texcoord_pct;\n"
"  vec2 sdf_sample_pos;\n"
"  vec4 tint;\n"
"  float corner_radius_px;\n"
"  flat float border_thickness_px;\n"
"  flat float softness_px;\n"
"  flat float omit_texture;\n"
"} fs_in;\n"
"\n"
"layout (std140) uniform R_GL_Uniforms_Rect // Binding Point 0\n"
"{\n"
"  vec2 viewport_size_px;\n"
"  float opacity;\n"
"  // float _padding0_;\n"
"  mat4 texture_sample_channel_map;\n"
"  vec2 texture_t2d_size_px;\n"
"  // vec2 translate;\n"
"  mat3 xform;\n"
"  vec2 xform_scale;\n"
"  // vec2 _padding1_;\n"
"};\n"
"\n"
"uniform sampler2D main_t2d; // Texture Unit 0\n"
"\n"
"out vec4 FragColor;\n"
"\n"
"// Corrected SDF function\n"
"float rect_sdf(vec2 sample_pos, vec2 rect_half_size, float r)\n"
"{\n"
"  vec2 d = abs(sample_pos) - rect_half_size + r;\n"
"  return length(max(d, 0.0)) - r;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"  // Tint is already interpolated\n"
"  vec4 tint = fs_in.tint;\n"
"\n"
"  // Sample texture\n"
"  vec4 albedo_sample = vec4(1.0);\n"
"  if(fs_in.omit_texture < 0.5) // Use < 0.5 for bool comparison\n"
"  {\n"
"    // REMOVED explicit V flip added previously. Use coords directly from VS.\n"
"    albedo_sample = texture(main_t2d, fs_in.texcoord_pct) * texture_sample_channel_map;\n"
"  }\n"
"\n"
"  // Determine SDF sample position (already interpolated)\n"
"  vec2 sdf_sample_pos = fs_in.sdf_sample_pos; // Keep for potential future use\n"
"\n"
"  // Sample for borders\n"
"  float border_sdf_t = 1.0; // Default to 1 (no border effect)\n"
"  float softness_px = max(fs_in.softness_px, 0.01); // Ensure softness is positive\n"
"  float border_thickness_px = fs_in.border_thickness_px;\n"
"  if(border_thickness_px > 0.0)\n"
"  {\n"
"    // Adjust half size by softness before calculating SDF, matching D3D11\n"
"    vec2 inner_half_size = fs_in.rect_half_size_px - vec2(softness_px * 2.0) - border_thickness_px;\n"
"    float inner_radius = max(fs_in.corner_radius_px - border_thickness_px, 0.0);\n"
"    float border_sdf_s = rect_sdf(sdf_sample_pos, inner_half_size, inner_radius);\n"
"\n"
"    float border_smooth_range = max(2.0 * softness_px, 1.0);\n"
"    // Calculate coverage *outside* the inner edge (0 inside fill, ramps to 1 outside)\n"
"    border_sdf_t = smoothstep(0.0, border_smooth_range, border_sdf_s);\n"
"  }\n"
"\n"
"  // Sample for corners (outer edge)\n"
"  float corner_sdf_t = 1.0; // Default to 1 (no corner effect)\n"
"  // Check radius OR softness > 0.75 (D3D11 logic)\n"
"  if(fs_in.corner_radius_px > 0.0 || softness_px > 0.75)\n"
"  {\n"
"    // Adjust half size by softness before calculating SDF, matching D3D11\n"
"    vec2 outer_half_size = fs_in.rect_half_size_px - vec2(softness_px * 2.0);\n"
"    float outer_radius = max(fs_in.corner_radius_px, 0.0);\n"
"    float corner_sdf_s = rect_sdf(sdf_sample_pos, outer_half_size, outer_radius);\n"
"\n"
"    float corner_smooth_range = max(2.0 * softness_px, 1.0);\n"
"    // Calculate coverage *inside* the outer edge (1 inside, ramps to 0 outside)\n"
"    corner_sdf_t = 1.0 - smoothstep(0.0, corner_smooth_range, corner_sdf_s);\n"
"  }\n"
"\n"
"  // Form final color - Multiply tint and texture colors, combine alphas\n"
"  FragColor.rgb = tint.rgb * albedo_sample.rgb; // Multiply RGB components\n"
"  FragColor.a   = tint.a * albedo_sample.a;   // Multiply Alpha components\n"
"\n"
"  // Apply global opacity and SDF alpha factors\n"
"  FragColor.a *= opacity;\n"
"  FragColor.a *= corner_sdf_t; // Multiply by corner coverage\n"
"  FragColor.a *= border_sdf_t; // Multiply by border coverage\n"
"\n"
"  // Final discard if alpha is near zero\n"
"  if (FragColor.a < 0.001)\n"
"  {\n"
"    discard;\n"
"  }\n"
"}\n"
""
);

read_only global String8 r_gl_g_blur_shader_vs_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"// Define uniforms matching the FS for rect/corners\n"
"layout (std140) uniform BlurUniforms // Binding Point 1 \n"
"{\n"
"  vec4 rect;                  // vec4(min.x, min.y, max.x, max.y) \n"
"  vec4 corner_radii_px;       // vec4(bl, tl, br, tr) \n"
"  vec2 direction;             // vec2(dx, dy) unit vector for blur pass \n"
"  vec2 viewport_size;         // vec2(width, height) of render target \n"
"  uint blur_count;            // Number of samples (adjusted for bilinear) \n"
"  // padding... \n"
"  vec4 kernel[32];            // vec4(weight, offset, unused, unused) \n"
"};\n"
"\n"
"// Define output block to pass SDF data to FS\n"
"out VS_OUT {\n"
"  vec2 sdf_sample_pos;\n"
"  flat vec2 rect_half_size;\n"
"  float corner_radius;\n"
"} vs_out;\n"
"\n"
"out vec2 TexCoord;\n"
"\n"
"void main()\n"
"{\n"
"  // Fullscreen quad vertices (-1,-1), (1,-1), (-1, 1), (1, 1) using triangle strip\n"
"  // VertexID: 0 -> (-1,-1), 1 -> (1,-1), 2 -> (-1, 1), 3 -> (1, 1)\n"
"  vec2 pos = vec2( (gl_VertexID << 1) - 1.0, (gl_VertexID & 1) * 2.0 - 1.0 );\n"
"  gl_Position = vec4(pos, 0.0, 1.0);\n"
"  \n"
"  // Texcoord (0,0) bottom-left to (1,1) top-right \n"
"  TexCoord = pos * 0.5 + 0.5; \n"
"  // TexCoord.y = 1.0 - TexCoord.y; // Y is already correct for fullscreen quad\n"
"\n"
"  // Calculate SDF inputs\n"
"  vs_out.rect_half_size = (rect.zw - rect.xy) * 0.5;\n"
"  \n"
"  // Determine cornercoords based on vertex ID (0: BL, 1: BR, 2: TL, 3: TR)\n"
"  vec2 cornercoords_pct = vec2(float(gl_VertexID & 1), float((gl_VertexID >> 1) & 1)); // Renamed from cornercoords__pct\n"
"  vs_out.sdf_sample_pos = (2.0 * cornercoords_pct - 1.0) * vs_out.rect_half_size;\n"
"\n"
"  // Select corner radius based on vertex ID\n"
"  // ID 0 (BL) -> radii.x\n"
"  // ID 1 (BR) -> radii.z\n"
"  // ID 2 (TL) -> radii.y\n"
"  // ID 3 (TR) -> radii.w\n"
"  if(gl_VertexID == 0) vs_out.corner_radius = corner_radii_px.x;\n"
"  else if(gl_VertexID == 1) vs_out.corner_radius = corner_radii_px.z;\n"
"  else if(gl_VertexID == 2) vs_out.corner_radius = corner_radii_px.y;\n"
"  else /* ID 3 */          vs_out.corner_radius = corner_radii_px.w;\n"
"\n"
"  // D3D11 vertex shader passes rect_half_size - 2.0. Match this.\n"
"  vs_out.rect_half_size -= 2.0; \n"
"}\n"
""
);

read_only global String8 r_gl_g_blur_shader_fs_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"in vec2 TexCoord;\n"
"// Added input block matching the VS structure (even if VS isn't updated yet)\n"
"in VS_OUT {\n"
"  vec2 sdf_sample_pos;\n"
"  flat vec2 rect_half_size;\n"
"  float corner_radius;\n"
"} fs_in;\n"
"out vec4 FragColor;\n"
"\n"
"uniform sampler2D main_t2d; // Texture Unit 0 \n"
"\n"
"layout (std140) uniform BlurUniforms // Binding Point 1 \n"
"{\n"
"  vec4 rect;                  // vec4(min.x, min.y, max.x, max.y) \n"
"  vec4 corner_radii_px;       // vec4(bl, tl, br, tr) \n"
"  vec2 direction;             // vec2(dx, dy) unit vector for blur pass \n"
"  vec2 viewport_size;         // vec2(width, height) of render target \n"
"  uint blur_count;            // Number of samples (adjusted for bilinear) \n"
"  // padding... \n"
"  vec4 kernel[32];            // vec4(weight, offset, unused, unused) \n"
"};\n"
"\n"
"// SDF for rounded rectangle \n"
"float rect_sdf(vec2 sample_pos, vec2 rect_half_size, float r)\n"
"{\n"
"  vec2 d = abs(sample_pos) - rect_half_size + r;\n"
"  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0) - r;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"  vec4 sum = vec4(0.0);\n"
"  vec2 uv = TexCoord;\n"
"  vec2 texelSize = 1.0 / viewport_size;\n"
"  \n"
"  // Apply first weight (at offset 0)\n"
"  sum += texture(main_t2d, uv) * kernel[0].x;\n"
"  \n"
"  // Apply remaining weights using bilinear optimization\n"
"  for(uint i = 1u; i < blur_count; ++i)\n"
"  {\n"
"    vec2 offset = direction * kernel[i].y * texelSize;\n"
"    sum += texture(main_t2d, uv + offset) * kernel[i].x;\n"
"    sum += texture(main_t2d, uv - offset) * kernel[i].x;\n"
"  }\n"
"  \n"
"  // Clip to rounded rectangle using SDF\n"
"  float corner_sdf_s = rect_sdf(fs_in.sdf_sample_pos, fs_in.rect_half_size, fs_in.corner_radius);\n"
"  // D3D11 uses smoothstep(0, 2*softness, ...), let's use a small fixed softness for now\n"
"  float softness = 1.0; \n"
"  float corner_sdf_t = 1.0 - smoothstep(-softness, softness, corner_sdf_s);\n"
"\n"
"  // Discard fragments outside the rounded rectangle (similar to D3D11)\n"
"  if (corner_sdf_t < 0.001) // Use a small threshold instead of 0.9 check\n"
"  {\n"
"    discard;\n"
"  }\n"
"\n"
"  FragColor = vec4(sum.rgb, 1.0); // Output color, force alpha to 1\n"
"\n"
"  // Optional: Apply coverage to alpha if needed later\n"
"  // FragColor.a = corner_sdf_t; \n"
"}\n"
""
);

read_only global String8 r_gl_g_mesh_shader_vs_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n"
"layout (location = 1) in vec3 aNormal;\n"
"layout (location = 2) in vec2 aTexCoord;\n"
"layout (location = 3) in vec3 aColor;\n"
"layout (location = 4) in mat4 instance_xform; // Per-instance transform \n"
"\n"
"layout (std140) uniform R_GL_Uniforms_Mesh { // Use correct uniform block name matching C struct\n"
"  mat4 view_proj_matrix; // Combined view * projection \n"
"};\n"
"\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"out vec2 TexCoords;\n"
"out vec3 VertexColor;\n"
"\n"
"void main()\n"
"{\n"
"  vec4 worldPos = instance_xform * vec4(aPos, 1.0);\n"
"  gl_Position = view_proj_matrix * worldPos;\n"
"  FragPos = vec3(worldPos);\n"
"  Normal = mat3(transpose(inverse(instance_xform))) * aNormal; // Correct normal transformation\n"
"  TexCoords = aTexCoord;\n"
"  VertexColor = aColor;\n"
"}\n"
""
);

read_only global String8 r_gl_g_mesh_shader_fs_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"in vec2 TexCoords;\n"
"in vec3 VertexColor;\n"
"\n"
"uniform sampler2D main_t2d; // Texture Unit 0 \n"
"\n"
"void main()\n"
"{\n"
"  // Simple: Output vertex color modulated by texture (if available) \n"
"  // vec4 texColor = texture(main_t2d, TexCoords); \n"
"  FragColor = vec4(VertexColor, 1.0); // * texColor; // Modulate later if needed \n"
"  // Add lighting calculations here if needed \n"
"}\n"
""
);

read_only global String8 r_gl_g_geo3dcomposite_shader_fs_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"in vec2 TexCoord;\n"
"uniform sampler2D main_t2d; // Renamed from stage_t2d \n"
"out vec4 FragColor;\n"
"void main()\n"
"{\n"
"  FragColor = texture(main_t2d, TexCoord); // Use renamed uniform\n"
"}\n"
""
);

read_only global String8 r_gl_g_finalize_shader_vs_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"out vec2 TexCoord;\n"
"void main()\n"
"{\n"
"  // Correct way for (-1,-1), (1,-1), (-1, 1), (1, 1) triangle strip \n"
"  vec2 pos = vec2( (gl_VertexID & 1) * 2.0 - 1.0, (gl_VertexID & 2) - 1.0 ); \n"
"  gl_Position = vec4(pos, 0.0, 1.0);\n"
"  // Texcoord (0,0) bottom-left to (1,1) top-right \n"
"  TexCoord = pos * 0.5 + 0.5;\n"
"  // TexCoord.y = 1.0 - TexCoord.y; // Flip V if input texture requires it \n"
"}\n"
""
);

read_only global String8 r_gl_g_finalize_shader_fs_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"in vec2 TexCoord;\n"
"uniform sampler2D main_t2d; // Renamed from stage_t2d \n"
"out vec4 FragColor;\n"
"void main()\n"
"{\n"
"  FragColor = texture(main_t2d, TexCoord); // Use renamed uniform\n"
"  FragColor.a = 1.0; // Force alpha to 1 for final output \n"
"}\n"
""
);


C_LINKAGE_END

#endif // RENDER_OPENGL_META_H
